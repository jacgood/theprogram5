#!/usr/bin/env python3
"""
MySQL to PostgreSQL Migration Script
Converts MySQL dump to PostgreSQL-compatible format
"""

import re
import sys
import argparse
from pathlib import Path

class MySQLToPostgresConverter:
    def __init__(self):
        self.mysql_to_postgres_types = {
            # Numeric types
            'TINYINT': 'SMALLINT',
            'MEDIUMINT': 'INTEGER',
            'BIGINT': 'BIGINT',
            'INT': 'INTEGER',
            'INTEGER': 'INTEGER',
            'DECIMAL': 'DECIMAL',
            'FLOAT': 'REAL',
            'DOUBLE': 'DOUBLE PRECISION',
            
            # String types
            'LONGTEXT': 'TEXT',
            'MEDIUMTEXT': 'TEXT',
            'TINYTEXT': 'TEXT',
            'TEXT': 'TEXT',
            'VARCHAR': 'VARCHAR',
            'CHAR': 'CHAR',
            
            # Date/Time types
            'DATETIME': 'TIMESTAMP',
            'TIMESTAMP': 'TIMESTAMP',
            'DATE': 'DATE',
            'TIME': 'TIME',
            'YEAR': 'INTEGER',
            
            # Binary types
            'BLOB': 'BYTEA',
            'LONGBLOB': 'BYTEA',
            'MEDIUMBLOB': 'BYTEA',
            'TINYBLOB': 'BYTEA',
            'BINARY': 'BYTEA',
            'VARBINARY': 'BYTEA',
            
            # Other types
            'ENUM': 'VARCHAR',
            'SET': 'TEXT'
        }
        
        # Skip system databases
        self.skip_databases = {'mysql', 'information_schema', 'performance_schema', 'sys', 'phpmyadmin'}
        
    def convert_data_types(self, line):
        """Convert MySQL data types to PostgreSQL equivalents"""
        for mysql_type, postgres_type in self.mysql_to_postgres_types.items():
            # Handle type with parameters like VARCHAR(255)
            pattern = r'\b' + mysql_type + r'(\([^)]*\))?'
            if mysql_type in ['ENUM', 'SET']:
                # Special handling for ENUM and SET
                line = re.sub(pattern, postgres_type + '(255)', line, flags=re.IGNORECASE)
            else:
                line = re.sub(pattern, postgres_type + r'\1', line, flags=re.IGNORECASE)
        
        return line
    
    def convert_create_table(self, line):
        """Convert CREATE TABLE statements"""
        # Remove MySQL-specific options
        line = re.sub(r'ENGINE=\w+', '', line, flags=re.IGNORECASE)
        line = re.sub(r'DEFAULT CHARSET=\w+', '', line, flags=re.IGNORECASE)
        line = re.sub(r'COLLATE=\w+', '', line, flags=re.IGNORECASE)
        line = re.sub(r'AUTO_INCREMENT=\d+', '', line, flags=re.IGNORECASE)
        line = re.sub(r'COMMENT=\'[^\']*\'', '', line, flags=re.IGNORECASE)
        
        # Convert AUTO_INCREMENT to SERIAL
        line = re.sub(r'AUTO_INCREMENT', 'DEFAULT nextval(\'seq_name\')', line, flags=re.IGNORECASE)
        
        # Convert backticks to double quotes
        line = re.sub(r'`([^`]+)`', r'"\1"', line)
        
        # Handle MySQL collation
        line = re.sub(r'CHARACTER SET \w+', '', line, flags=re.IGNORECASE)
        line = re.sub(r'COLLATE \w+', '', line, flags=re.IGNORECASE)
        
        return line
    
    def convert_insert(self, line):
        """Convert INSERT statements"""
        # Convert backticks to double quotes
        line = re.sub(r'`([^`]+)`', r'"\1"', line)
        
        # Handle MySQL's \0 in data
        line = line.replace('\\0', '')
        
        return line
    
    def should_skip_database(self, db_name):
        """Check if database should be skipped"""
        return db_name.lower() in self.skip_databases
    
    def convert_dump(self, input_file, output_file):
        """Convert MySQL dump to PostgreSQL format"""
        print(f"Converting {input_file} to {output_file}...")
        
        current_database = None
        skip_current_db = False
        
        with open(input_file, 'r', encoding='utf-8', errors='ignore') as infile, \
             open(output_file, 'w', encoding='utf-8') as outfile:
            
            # Write PostgreSQL header
            outfile.write("-- PostgreSQL dump converted from MySQL\n")
            outfile.write("-- DO NOT EDIT: Generated by mysql_to_postgres.py\n\n")
            outfile.write("SET client_encoding = 'UTF8';\n")
            outfile.write("SET standard_conforming_strings = on;\n")
            outfile.write("SET check_function_bodies = false;\n")
            outfile.write("SET client_min_messages = warning;\n\n")
            
            for line_num, line in enumerate(infile, 1):
                original_line = line.strip()
                
                # Skip MySQL-specific comments and settings
                if (line.startswith('/*!') or 
                    line.startswith('--') and any(x in line.lower() for x in ['mysql', 'host:', 'server version']) or
                    'LOCK TABLES' in line or 
                    'UNLOCK TABLES' in line or
                    'DISABLE KEYS' in line or
                    'ENABLE KEYS' in line):
                    continue
                
                # Detect database creation
                db_match = re.search(r'CREATE DATABASE.*?`([^`]+)`', line, re.IGNORECASE)
                if db_match:
                    current_database = db_match.group(1)
                    skip_current_db = self.should_skip_database(current_database)
                    
                    if skip_current_db:
                        print(f"Skipping system database: {current_database}")
                        continue
                    else:
                        print(f"Processing database: {current_database}")
                        outfile.write(f'-- Database: {current_database}\n')
                        outfile.write(f'CREATE DATABASE "{current_database}";\n')
                        outfile.write(f'\\c "{current_database}";\n\n')
                        continue
                
                # Skip if we're in a system database
                if skip_current_db:
                    continue
                
                # Convert USE statements
                use_match = re.search(r'USE `([^`]+)`;', line, re.IGNORECASE)
                if use_match:
                    db_name = use_match.group(1)
                    if not self.should_skip_database(db_name):
                        outfile.write(f'\\c "{db_name}";\n\n')
                    continue
                
                # Convert CREATE TABLE statements
                if line.upper().startswith('CREATE TABLE'):
                    line = self.convert_create_table(line)
                    line = self.convert_data_types(line)
                
                # Convert INSERT statements
                elif line.upper().startswith('INSERT INTO'):
                    line = self.convert_insert(line)
                
                # Convert other statements
                else:
                    line = self.convert_data_types(line)
                    # Convert backticks to double quotes
                    line = re.sub(r'`([^`]+)`', r'"\1"', line)
                
                # Write the converted line
                if line.strip():
                    outfile.write(line)
        
        print(f"Conversion completed! Output written to {output_file}")

def main():
    parser = argparse.ArgumentParser(description='Convert MySQL dump to PostgreSQL format')
    parser.add_argument('input_file', help='Input MySQL dump file')
    parser.add_argument('output_file', help='Output PostgreSQL dump file')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    input_path = Path(args.input_file)
    if not input_path.exists():
        print(f"Error: Input file {input_path} does not exist")
        sys.exit(1)
    
    converter = MySQLToPostgresConverter()
    converter.convert_dump(args.input_file, args.output_file)

if __name__ == '__main__':
    main()